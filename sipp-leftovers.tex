Then \astar-style search is performed utilizing the computed intervals to find a safe plan. Guided by a consistent heuristic, \sipp guarantees finding such a plan (if it exists). Moreover, \sipp gaurantees that this plan is optimal w.r.t. time. 
There are sub-optimal and anytime variations of the algorithm are also known \cite{narayanan2012anytime,yakovlev2020revisiting}, but in this work we use the basic, optimal, \sipp. 
Next we describe the main ideas of SIPP. Without the loss of generality we will consider both the agent and the obstacles to be disks of the same size (radius equals $r$).
The crux of the method is the notion of the safe interval for a graph vertex~\cite{phillips2011sipp}. The latter \dor{Out of whom?} is a contiguous period of time for a vertex, during which no collision happens with the dynamic obstacles if an agent occupies the vertex. Safe intervals are opposed to collision intervals, and are assumed to be maximal, i.e. extending a safe interval is not possible.

For example, consider a case when only one dynamic obstacle is presented and this obstacle passes in the vicinity of the graph vertex $v$. Moreover the distance between this obstacle and $v$ is less than $2r$ between time moments $t_1$ and $t_2$. This effectively means that the latter moments define a collision interval for $v$ -- $(t_1, t_2)$ -- and the inversion of that interval defines two safe intervals: $[0, t_1]$ and $[t2, +\infty]$ \footnote{We assume that collision happens only when the distance between two disks is less than the sum of their radii, when the distance is equal to it -- no collision happens.}. \dor{Maybe it should be $[t2, +\infty)$}

In general the number of safe intervals is proportional to the number of the obstacles that pass nearby the vertex. The chronologically last safe interval for a vertex might end not with the $\infty$ -- e.g. some obstacle comes to this vertex and stays in it. The safe interval might be an $\emptyset$ as well -- consider e.g. an obstacle that constantly moves back-and-forth in the vicinity of the vertex.

SIPP uses safe intervals to define the search nodes that correspond to graph vertices. Thus numerous distinct search nodes corresponding to the same vertex but different safe time intervals might exist. In the described case, nodes $n_1=\langle v, [0, t_1] \rangle$ and $n_2=\langle v, [t_2, +\infty] \rangle$ that both correspond to the same vertex $v$ might be generated by the planner.

For each node SIPP mantains $g$-value -- the cost of the best-known plan that ends at this vertex, $h$-value -- heuristic estimate of the cost to the goal, $parent$ -- the predecessor node in the search-tree, $EAT$-value -- the earliest possible time within the safe interval the node can be reach from $parent$. In the considered domain $g(n)$ and $EAT(n)$ are equivalent as the cost of the plan is the time the agent needs to execute it. Earliest possible arrival time for a node is computed when its predecessor is expanded. Being a planning algorithm, SIPP assumes that the exact procedure of computing this time moment is available.

